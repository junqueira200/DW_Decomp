/*
    Modificado por Igor de Andrade Junqueira,
    comentario original:

    Safe C++, Or How to Avoid Most Common Mistakes in C++ Code by Vladimir Kushnir, (OÃ•Reilly).
    Copyright 2012 Vladimir Kushnir, ISBN 9781449320935.
    If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at permissions@oreilly.com.
*/

#ifndef DW_SAFE_3D_MATRIX_H
#define DW_SAFE_3D_MATRIX_H

#include <vector>
#include <iostream>


// Wrapper around std::vector, has temporary sanity checks in the operators [].
template <typename T, bool C=true>
class Vector3D : public std::vector<T>
{
private:
    size_t n=0;
    size_t m=0;
    size_t p=0;

    T get(size_t i)const{return std::vector<T>::operator[](i);}

public:

    explicit Vector3D(size_t n_, size_t m_, size_t p_): std::vector<T>(n_*m_*p_), n(n_), m(m_), p(p_){}

    Vector3D(size_t n_, size_t m_, size_t p_, const T& value): std::vector<T>(n_*m_*p_, value), n(n_), m(m_), p(p_){}

    Vector3D(size_t n): std::vector<T>(n){}
    Vector3D(){}

    Vector3D(const Vector3D<T> &temp):n(temp.n), m(temp.n), p(temp.p), std::vector<T>(temp.n*temp.m*temp.p)
    {
        for(int i=0; i < n*m*p; ++i)
            std::vector<T>::operator[](i) = temp.get(i);
    }


//    template <class InputIterator> Vector (InputIterator first, InputIterator last): std::vector<T>(first, last){}

    // Note: we do not provide a copy-ctor and assignment operator.
    // we rely on default versions of these methods generated by the compiler.

    T& operator[](size_t index) = delete;
    const T& operator[](size_t index) const = delete;


    virtual inline __attribute__((always_inline)) T operator()(size_t indexI, size_t indexJ, size_t indexK) const
    {

        size_t index = indexI*m*p + indexJ*p + indexK;

        if constexpr(C)
        {

#if VAR_VECTOR_SANITY_CHECK
            if(indexI >= n)
            {
                std::cout << "Erro indice i: " << indexI << " esta errado para matrix de tam " << n << " x " << m
                          <<" x "<<p<< "\n";
                throw std::out_of_range("");
            }


            if(indexJ >= m)
            {
                std::cout << "Erro indice j: " << indexJ << " esta errado para matrix de tam " << n << " x " << m
                          <<" x "<<p<< "\n";
                throw std::out_of_range("");
            }

            if(indexK >= p)
            {

                std::cout << "Erro indice k: " << indexK << " esta errado para vetor de tam " << n << " x " << m
                          <<" x "<<p<<"\n";
                throw std::out_of_range("");
            }

            if(index >= m*n*p)
            {
                std::cout << "Erro indice(" << index << ") >= " << m*n*p << "\n";
                std::cout << "i=" << indexI << "; j=" << indexJ << "; k="<<indexK<<"\n";

                throw std::out_of_range("");
            }
#endif
        }

        return std::vector<T>::operator[](index);
    }

    virtual inline __attribute__((always_inline)) T& get(size_t indexI, size_t indexJ, size_t indexK)
    {

        size_t index = indexI*m*p + indexJ*p + indexK;

#if VAR_VECTOR_SANITY_CHECK
        if(indexI >= n)
        {
            std::cout << "Erro indice i: " << indexI << " esta errado para matrix de tam " << n << " x " << m
                      <<" x "<<p<< "\n";
            throw std::out_of_range("");
        }


        if(indexJ >= m)
        {
            std::cout << "Erro indice j: " << indexJ << " esta errado para matrix de tam " << n << " x " << m
                      <<" x "<<p<< "\n";
            throw std::out_of_range("");
        }

        if(indexK >= p)
        {

            std::cout << "Erro indice k: " << indexK << " esta errado para vetor de tam " << n << " x " << m
                      <<" x "<<p<<"\n";
            throw std::out_of_range("");
        }

        if(index >= m*n*p)
        {
            std::cout << "Erro indice(" << index << ") >= " << m*n*p << "\n";
            std::cout << "i=" << indexI << "; j=" << indexJ << "; k="<<indexK<<"\n";

            throw std::out_of_range("");
        }
#endif


        return std::vector<T>::operator[](index);
    }

    [[nodiscard]] virtual size_t inline __attribute__((always_inline)) getNumDimI() const
    {
        return n;
    }


    [[nodiscard]] virtual size_t inline __attribute__((always_inline)) getNumDimJ() const
    {
        return m;
    }


    [[nodiscard]] virtual size_t inline __attribute__((always_inline)) getNumDimK() const
    {
        return p;
    }

    virtual void setVal(const T &val)
    {
        for(int i=0; i < m*n*p; ++i)
            std::vector<T>::operator[](i) = val;
    }
    virtual void setVal(const T &&val)
    {
        for(int i=0; i < m*n*p; ++i)
            std::vector<T>::operator[](i) = val;
    }

    virtual void printVector()
    {
        for(int i=0; i < m*n*p; ++i)
            std::cout<<std::vector<T>::operator[](i)<<" ";
        std::cout<<"\n";
    }

    /*
    virtual void resize(size_t n_, size_t m_, size_t p_)
    {
        n = n_;
        m = m_;
        p = p_;

        std::vector<T>(n*m*p);
    }


    virtual void resize(size_t n_, size_t m_, size_t p_, T &val)
    {
        n = n_;
        m = m_;
        p = p_;

        std::vector<T>(n*m*p);
        setVal(val);
    }


    virtual void resize(size_t n_, size_t m_, size_t p_, T &&val)
    {
        n = n_;
        m = m_;
        p = p_;

        std::vector<T>(n*m*p);
        setVal(val);
    }
    */


    //Matrix(size_t n, const T &val): std::vector<T>(n, val){}

};



#endif //DW_SAFE_3D_MATRIX_H
