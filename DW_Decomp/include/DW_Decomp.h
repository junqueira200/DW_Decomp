#include "gurobi_c++.h"
#include <Eigen/Eigen>
#include <memory>
#include "Aux.h"
#include "Sparse.h"

#ifndef DW_DECOMP_DW_DECOMP_H
#define DW_DECOMP_DW_DECOMP_H

using namespace SparseNS;

namespace DW_DecompNS
{

    inline const double TolObjSubProb = 1E-5;

    Eigen::MatrixXd getMatA_Model(GRBModel &mestre);
    void getSparseMatColModel(GRBModel &model, SparseMatColD &matA);

    Eigen::VectorXd getVetC_Model(GRBModel &mestre);
    void getVetC_Model(GRBModel &model, SparseVectorD &vetC);

    Eigen::VectorX<char> getConstSenseModel(GRBModel &model);
    Eigen::VectorXd getRhsModel(GRBModel &model);
    void recuperaX(GRBVar *var, Eigen::VectorXd &vetX, int numVar);


    enum StatusProb
    {
        StatusSubProb_Otimo    = 0,
        StatusSubProb_Inviavel,
        StatusSubProb_Unbounded,
        StatusSubProb_Outro
    };


    class SubProb
    {
        public:

        Eigen::MatrixXd *matA = nullptr;

        virtual ~SubProb(){};

        // Responsavel por adicionar as restricoes de convexidade
        virtual void iniConvConstr(GRBModel &rmlp, void *data, const double custoVarA) =0;

        /** ************************************************************************
         *  ************************************************************************
         *
         *  Resolve o subproblema e add cooef das restricoes de conv
         *
         *  @param subProbCooef
         *  @param rmlp
         *  @param vetX
         *  @param itCG
         *  @param custoRedNeg
         *  @param data
         *  @param iniConv
         *  @param indSubProb
         *  @param vetCooefRestConv
         *  @param pairSubProb           Pair representa o indice do inicio das
         *                             variaveis do sub problema e o seu tamanho
         *
         *  ************************************************************************
         *  ************************************************************************
         */
        virtual int resolveSubProb(Eigen::VectorXd &subProbCooef,
                                   GRBModel &rmlp,
                                   Eigen::VectorXd &vetX,
                                   int itCG,
                                   bool &custoRedNeg,
                                   void *data,
                                   const int iniConv,
                                   int indSubProb,
                                   Eigen::VectorXd &vetCooefRestConv,
                                   const std::pair<int, int> &pairSubProb)=0;


         virtual int resolveSubProb(SparseVectorD &subProbCooef,
                                   GRBModel &rmlp,
                                   SparseVectorD &vetX,
                                   int itCG,
                                   bool &custoRedNeg,
                                   void *data,
                                   const int iniConv,
                                   int indSubProb,
                                   SparseVectorD &vetCooefRestConv,
                                   const std::pair<int, int> &pairSubProb){};

        virtual int64_t getNumberOfConvConstr() = 0;
    };


    void dwDecomp(GRBEnv &env,
                  GRBModel &mestre,
                  double custoVarA,
                  const std::vector<std::pair<int, int>> &&vetPairSubProb,
                  SubProb *subProb,
                  void *data,
                  const int numSubProb);

    template<typename T>
    class DelVetFunctor
    {
    public:
        void operator()(T *ptr){ delete []ptr;}
    };

    class DW_DecompNode
    {
    public:
        GRBEnv *ptrEnv                   = nullptr;  // Env of Gurobi (DO NOT DELETE)
        GRBModel *ptrMaster              = nullptr;  // Master model, it has the original variables and constraints  (DO NOT DELETE)
        SubProb *ptrSubProb              = nullptr;  // Ptr for class SubProb (DO NOT DELETE)
        std::unique_ptr<GRBModel>  uRmlp = nullptr;  // Ptr for rmlp model. DELETE!

        int numSubProb                   = 0;        // Number of sub problems
        double costA_Var                 = 0.0;
        int64_t numConstrsConv           = 0;        // Number of constants of convexity

        SparseMatColD matA;
        Vector<std::pair<int, int>> vetPairSubProb;

        Vector<std::unique_ptr<SparseVectorD>> vetVarLambda;             // Vectors generated by sub problems X
        SparseVectorD vetRmlpPi;
        SparseVectorD vetC;
        SparseVectorD vetSubProbCooef;
        SparseVectorD vetX_solSubProb;
        SparseVectorD vetConvCooef;
        VectorD vetCooef;
        Vector<SparseMatColD> vetSubMatA;

        GRBConstr* vetRmlpConstr = nullptr;
        GRBVar* vetVarArtifRmlp = nullptr;

        Vector<GRBLinExpr> vetLinExprRmlp;



        DW_DecompNode(GRBEnv &env_,
                      GRBModel &master_,
                      double costA_Var_,
                      Vector<std::pair<int, int>> vetPairSubProb_,
                      SubProb *ptrSubProb_,
                      const int numSubProb_);

        StatusProb columnGeneration();

        DW_DecompNode(const DW_DecompNode &decomp)
        {
            assertm(1, "NAO IMPLEMENTADO");
        }

        ~DW_DecompNode()
        {

            delete []vetRmlpConstr;
            delete []vetVarArtifRmlp;
            delete []vetRmlpConstr;
        }


        void funcUpdateRmlpPi();
        void funcGetSubProbCooef(int k);

    };
}


#endif //DW_DECOMP_DW_DECOMP_H
