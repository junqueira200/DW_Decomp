#include "gurobi_c++.h"
#include <Eigen/Eigen>
#include <memory>
#include "Aux.h"
#include "Sparse.h"

#ifndef DW_DECOMP_DW_DECOMP_H
#define DW_DECOMP_DW_DECOMP_H


namespace DW_DecompNS
{
    inline const double TolObjSubProb = 1E-5;

    Eigen::MatrixXd getMatA_Model(GRBModel &mestre);
    void getSparseMatLinModel(GRBModel &model, SparseNS::SparseMatLin<double> &matA);

    Eigen::VectorXd getVetC_Model(GRBModel &mestre);
    void getVetC_Model(GRBModel &model, VectorD &vetC);

    Eigen::VectorX<char> getConstSenseModel(GRBModel &model);
    Eigen::VectorXd getRhsModel(GRBModel &model);
    void recuperaX(GRBVar *var, Eigen::VectorXd &vetX, int numVar);


    enum StatusProb
    {
        StatusSubProb_Otimo    = 0,
        StatusSubProb_Inviavel,
        StatusSubProb_Unbounded,
        StatusSubProb_Outro
    };


    class SubProb
    {
        public:

        Eigen::MatrixXd *matA = nullptr;

        virtual ~SubProb(){};

        // Responsavel por adicionar as restricoes de convexidade
        virtual void iniConvConstr(GRBModel &rmlp, void *data, const double custoVarA) =0;

        /** ************************************************************************
         *  ************************************************************************
         *
         *  Resolve o subproblema e add cooef das restricoes de conv
         *
         *  @param subProbCooef
         *  @param rmlp
         *  @param vetX
         *  @param itCG
         *  @param custoRedNeg
         *  @param data
         *  @param iniConv
         *  @param indSubProb
         *  @param vetCooefRestConv
         *  @param pairSubProb           Pair representa o indice do inicio das
         *                             variaveis do sub problema e o seu tamanho
         *
         *  ************************************************************************
         *  ************************************************************************
         */
        virtual int resolveSubProb(Eigen::VectorXd &subProbCooef,
                                   GRBModel &rmlp,
                                   Eigen::VectorXd &vetX,
                                   int itCG,
                                   bool &custoRedNeg,
                                   void *data,
                                   const int iniConv,
                                   int indSubProb,
                                   Eigen::VectorXd &vetCooefRestConv,
                                   const std::pair<int, int> &pairSubProb)=0;

        virtual int64_t getNumberOfConvConstr() = 0;
    };


    void dwDecomp(GRBEnv &env,
                  GRBModel &mestre,
                  double custoVarA,
                  const std::vector<std::pair<int, int>> &&vetPairSubProb,
                  SubProb *subProb,
                  void *data,
                  const int numSubProb);

    template<typename T>
    class DelVetFunctor
    {
    public:
        void operator()(T *ptr){ delete []ptr;}
    };

    class DW_DecompNode
    {
    public:
        GRBEnv *ptrEnv                   = nullptr;  // Env of Gurobi (DO NOT DELETE)
        GRBModel *ptrMaster              = nullptr;  // Master model, it has the original variables and constraints  (DO NOT DELETE)
        SubProb *ptrSubProb              = nullptr;  // Ptr for class SubProb (DO NOT DELETE)
        std::unique_ptr<GRBModel>  uRmlp = nullptr;  // Ptr for rmlp model. DELETE!

        int numSubProb                   = 0;        // Number of sub problems
        double costA_Var                 = 0.0;
        int64_t numConstrsConv           = 0;        // Number of constants of convexity

        SparseNS::SparseMatLin<double> matA;
        Vector<std::pair<int, int>> vetPairSubProb;

        Vector<std::unique_ptr<VectorD>> vetVarLambda;             // Vectors generated by sub problems X
        VectorD vetRmlpDuals; // X
        VectorD vetC;         // X
        VectorD vetSubProbCooef; // X
        VectorD vetX_solSubProb; // X
        VectorD vetConvCooef; // X
        Vector<SparseNS::SparseMatLin<double>> vetSubMatA; //X

        GRBConstr* vetRmlpConstr = nullptr;
        GRBVar* vetVarArtifRmlp = nullptr;

        Vector<GRBLinExpr> vetLinExprRmlp; // X



        DW_DecompNode(GRBEnv &env_,
                      GRBModel &master_,
                      double costA_Var_,
                      Vector<std::pair<int, int>> vetPairSubProb_,
                      SubProb *ptrSubProb_,
                      const int numSubProb_);

        StatusProb columnGeneration()
        {
            assertm(1, "NAO IMPLEMENTADO");
        }

        DW_DecompNode(const DW_DecompNode &decomp)
        {
            assertm(1, "NAO IMPLEMENTADO");
        }

        ~DW_DecompNode()
        {

            delete []vetRmlpConstr;
            delete []vetVarArtifRmlp;
        }

    };
}


#endif //DW_DECOMP_DW_DECOMP_H
