#include "gurobi_c++.h"
#include <Eigen/Eigen>
#include <memory>
#include "Aux.h"
#include "Sparse.h"

#ifndef DW_DECOMP_DW_DECOMP_H
#define DW_DECOMP_DW_DECOMP_H

using namespace SparseNS;

namespace DW_DecompNS
{

    inline const double TolObjSubProb = 1E-12;

    Eigen::MatrixXd getMatA_Model(GRBModel &mestre);
    void getSparseMatModel(GRBModel &model, Eigen::SparseMatrix<double, Eigen::RowMajor> &matA);

    Eigen::VectorXd getVetC_Model(GRBModel &mestre);
    void getVetC_Model(GRBModel &model, Eigen::RowVectorXd &vetC);

    Eigen::VectorX<char> getConstSenseModel(GRBModel &model);
    Eigen::VectorXd getRhsModel(GRBModel &model);
    void recuperaX(GRBVar *var, Eigen::VectorXd &vetX, int numVar);


    enum StatusProb
    {
        StatusSubProb_Otimo    = 0,
        StatusSubProb_Inviavel,
        StatusSubProb_Unbounded,
        StatusSubProb_Outro
    };


    class SubProb
    {
        public:

        Eigen::MatrixXd *matA = nullptr;

        SubProb()=default;
        virtual ~SubProb(){};

        virtual int getNumConvConstr()=0;

        // Responsavel por adicionar as restricoes de convexidade
        virtual void iniConvConstr(GRBModel &rmlp, void *data, const double custoVarA) =0;

        /** ************************************************************************
         *  ************************************************************************
         *
         *  Resolve o subproblema e add cooef das restricoes de conv
         *
         *  @param subProbCooef
         *  @param rmlp
         *  @param vetX
         *  @param itCG
         *  @param custoRedNeg
         *  @param data
         *  @param iniConv
         *  @param indSubProb
         *  @param vetCooefRestConv
         *  @param pairSubProb           Pair representa o indice do inicio das
         *                             variaveis do sub problema e o seu tamanho
         *
         *  ************************************************************************
         *  ************************************************************************
         */

        virtual int resolveSubProb(const Eigen::VectorXd &vetC,
                                   const Eigen::RowVectorXd &vetRowPi,
                                   GRBModel &rmlp,
                                   Eigen::VectorXd &vetX,
                                   int itCG,
                                   bool &custoRedNeg,
                                   void *data,
                                   const int iniConv,
                                   int indSubProb,
                                   Eigen::VectorXd &vetCooefRestConv,
                                   const std::pair<int, int> &pairSubProb)=0;


        //virtual int64_t getNumberOfConvConstr() = 0;
    };


    void dwDecomp(GRBEnv &env,
                  GRBModel &mestre,
                  double custoVarA,
                  const std::vector<std::pair<int, int>> &&vetPairSubProb,
                  SubProb *subProb,
                  void *data,
                  const int numSubProb);

    template<typename T>
    class DelVetFunctor
    {
    public:
        void operator()(T *ptr){ delete []ptr;}
    };

    class DW_DecompNode;

    struct AuxVectors
    {

        Vector<std::pair<int, int>> vetPairSubProb;

        Eigen::RowVectorXd          vetRowRmlpPi;
        Eigen::RowVectorXd          vetRowC;
        Eigen::VectorXd             vetColSubProbCooef;
        Eigen::VectorXd             vetColX_solSubProb;
        Eigen::VectorXd             vetColConvCooef;
        Eigen::VectorXd             vetColCooef;

        void updateSizes(DW_DecompNS::DW_DecompNode &e);
    };

    struct Info
    {
        int numSubProb         = 0;        // Number of sub problems
        double costA_Var       = 0.0;
        int64_t numConstrsConv = 0;        // Number of constants of convexity
        int numConstrsMaster   = 0;        // Number of the master's constrants
        int numVarMaster       = 0;        // Number of the variables into the master mip
        int numVarRmlpPi       = 0;        // Number of dual variables into the rmlp
    };

    class DW_DecompNode
    {
    public:
        SubProb* ptrSubProb              = nullptr;  // Ptr for class SubProb (DO NOT DELETE)
        std::unique_ptr<GRBModel>  uRmlp;            // Ptr for rmlp model
        int itCG = 0;

        Eigen::SparseMatrix<double, Eigen::RowMajor> matA;
        Vector<std::unique_ptr<Eigen::VectorXd>> vetVarLambdaCol;         // Vectors generated by sub problems
        Vector<Eigen::SparseMatrix<double, Eigen::RowMajor>> vetSubMatA;

        GRBConstr* vetRmlpConstr = nullptr;
        GRBVar* vetVarArtifRmlp  = nullptr;
        Vector<GRBLinExpr> vetLinExprRmlp;

        DW_DecompNode(GRBEnv &env_,
                      GRBModel &master_,
                      double costA_Var_,
                      SubProb *ptrSubProb_,
                      const int numSubProb_,
                      AuxVectors &auxVect,
                      Info &info);

        StatusProb columnGeneration(AuxVectors &auxVect, const Info &info);
        void getSubProbCooef(int k, AuxVectors &auxVect);
        void addColumn(const double cost, int k, AuxVectors &auxVect, const Info &info);
        void updateRmlpPi(Eigen::RowVectorXd &vetRowRmlpPi, const Info &info);

        // TODO
        DW_DecompNode(const DW_DecompNode &decomp)=delete;

        ~DW_DecompNode()
        {
            delete []vetRmlpConstr;
            delete []vetVarArtifRmlp;
        }

    };
}


#endif //DW_DECOMP_DW_DECOMP_H
