#include "gurobi_c++.h"
#include <Eigen/Eigen>
#include <memory>
#include "Aux.h"
#include "SparseMat.h"

#ifndef DW_DECOMP_DW_DECOMP_H
#define DW_DECOMP_DW_DECOMP_H


namespace DW_DecompNS
{
    inline const double TolObjSubProb = 1E-5;

    Eigen::MatrixXd getMatA_Model(GRBModel &mestre);
    Eigen::VectorXd getVetC_Model(GRBModel &mestre);
    Eigen::VectorX<char> getConstSenseModel(GRBModel &model);
    Eigen::VectorXd getRhsModel(GRBModel &model);
    void recuperaX(GRBVar *var, Eigen::VectorXd &vetX, int numVar);


    enum StatusProb
    {
        StatusSubProb_Otimo    = 0,
        StatusSubProb_Inviavel,
        StatusSubProb_Unbounded,
        StatusSubProb_Outro
    };


    class SubProb
    {
        public:

        Eigen::MatrixXd *matA = nullptr;

        virtual ~SubProb(){};

        // Responsavel por adicionar as restricoes de convexidade
        virtual void iniConvConstr(GRBModel &rmlp, void *data, const double custoVarA) =0;

        /** ************************************************************************
         *  ************************************************************************
         *
         *  Resolve o subproblema e add cooef das restricoes de conv
         *
         *  @param subProbCooef
         *  @param rmlp
         *  @param vetX
         *  @param itCG
         *  @param custoRedNeg
         *  @param data
         *  @param iniConv
         *  @param indSubProb
         *  @param vetCooefRestConv
         *  @param pairSubProb           Pair representa o indice do inicio das
         *                             variaveis do sub problema e o seu tamanho
         *
         *  ************************************************************************
         *  ************************************************************************
         */
        virtual int resolveSubProb(Eigen::VectorXd &subProbCooef,
                                   GRBModel &rmlp,
                                   Eigen::VectorXd &vetX,
                                   int itCG,
                                   bool &custoRedNeg,
                                   void *data,
                                   const int iniConv,
                                   int indSubProb,
                                   Eigen::VectorXd &vetCooefRestConv,
                                   const std::pair<int, int> &pairSubProb)=0;

        virtual int64_t getNumberOfConvConstr() = 0;
    };


    void dwDecomp(GRBEnv &env,
                  GRBModel &mestre,
                  double custoVarA,
                  const std::vector<std::pair<int, int>> &&vetPairSubProb,
                  SubProb *subProb,
                  void *data,
                  const int numSubProb);

    template<typename T>
    class DelVetFunctor
    {
    public:
        void operator()(T *ptr){ delete []ptr;}
    };

    class DW_DecompNode
    {
    public:
        GRBEnv *ptrEnv      = nullptr;  // Env of Gurobi (DO NOT DELETE)
        GRBModel *ptrMestre = nullptr;  // Master model, it has the original variables and constraints  (DO NOT DELETE)
        SubProb *ptrSubProb = nullptr;  // Ptr for class SubProb (DO NOT DELETE)

        int numSubProb      = 0;        // Number of sub problems
        SparseMatNS::SparseMatLin<double> matA;
        std::unique_ptr<GRBModel> uptrRmlp = nullptr;

        Vector<std::unique_ptr<VectorD>> vetVarLambda;             // Vectors generated by sub problems
        VectorD vetRmlpDuals;
        VectorD vetSubProbCooef;
        VectorD vetX_solSubProb;
        std::unique_ptr<GRBConstr, DelVetFunctor<GRBConstr>> uRmlpConstrs;



        DW_DecompNode(GRBEnv &env,
                      GRBModel &mestre,
                      double custoVarA_,
                      const std::vector<std::pair<int, int>> &&vetPairSubProb_,
                      SubProb *subProb_,
                      void *data_,
                      const int numSubProb_);

        StatusProb columnGeneration()
        {
            assertm(1, "NAO IMPLEMENTADO");
        }

        DW_DecompNode(const DW_DecompNode &decomp)
        {
            assertm(1, "NAO IMPLEMENTADO");
        }

        ~DW_DecompNode()
        {

        }

    };
}


#endif //DW_DECOMP_DW_DECOMP_H
